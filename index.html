#!/usr/bin/env python3 

# -- coding: utf-8 -- 

""" 

Capricorn — Think Backwards Game (CLI) 

Start with the end state. Reconstruct a backward causal chain that satisfies constraints. 

 

Run: python capricorn.py 

""" 

 

import json 

import os 

import sys 

from dataclasses import dataclass, field 

from typing import List, Dict, Callable, Any 

 

# ---------- Data structures ---------- 

 

@dataclass 

class Role: 

    id: str 

    name: str 

    tags: List[str] = field(default_factory=list) 

 

@dataclass 

class Clue: 

    id: str 

    title: str 

    text: str 

 

@dataclass 

class Cause: 

    id: str 

    text: str 

    tags: List[str] = field(default_factory=list) 

 

@dataclass 

class Constraint: 

    id: str 

    kind: str  # "negative", "required", "ordering", "quality" 

    text: str 

    # test(chain, ctx) -> True or str(error) 

    test: Callable[[List[Dict[str, str]], Dict[str, Any]], Any] 

 

@dataclass 

class Level: 

    id: str 

    title: str 

    end_state: str 

    meta: str 

    roles: List[Role] 

    clues: List[Clue] 

    causes: List[Cause] 

    constraints: List[Constraint] 

    solution: List[Dict[str, str]]  # for peek 

    hint: str 

 

# ---------- Levels ---------- 

 

def make_levels() -> List[Level]: 

    # L1: Lab incident 

    def cons_access(chain, ctx): 

        # No outsider referenced as cause 

        outsider_mention = any("outsider" in s["text"].lower() for s in chain) 

        return True if not outsider_mention else "Chain references outsider cause, violating access logs." 

 

    def cons_time(chain, ctx): 

        # Colleague cannot be root cause 

        if chain: 

            root_text = chain[-1]["text"].lower() 

            if "colleague" in root_text: 

                return "Colleague placed as root cause contrary to arrival time." 

        return True 

 

    def cons_protocol(chain, ctx): 

        # Must include protocol breach 

        has_breach = any( 

            any(k in s["text"].lower() for k in ["protocol", "neutralization", "ppe", "agitated", "unstable"]) 

            for s in chain 

        ) 

        return True if has_breach else "No protocol breach included; missing necessary explanation." 

 

    def cons_parsimony(chain, ctx): 

        seen = set() 

        redundant = 0 

        for s in chain: 

            k = s["text"].strip().lower() 

            if k in seen: 

                redundant += 1 

            seen.add(k) 

        if redundant > 0: 

            return f"Redundancy detected ({redundant} duplicate step{'s' if redundant>1 else ''})." 

        return True 

 

    L1 = Level( 

        id="L1", 

        title="Lab incident", 

        end_state="A biologist is found dead on the lab floor, surrounded by broken glassware and a spilled translucent solution. A colleague kneels beside him, holding his hand.", 

        meta="Location: research lab • Time: late evening • Weather: clear • Access: restricted keycard", 

        roles=[ 

            Role("victim","Lead Biologist",["expert","authorized"]), 

            Role("colleague","Senior Colleague",["authorized"]), 

            Role("tech","Lab Technician",["junior","authorized"]), 

            Role("admin","Building Admin",["maintenance","unauthorized-lab"]), 

            Role("outsider","Unknown Outsider",["unauthorized"]), 

        ], 

        clues=[ 

            Clue("c_micropetridish","Microscope view","A petri dish shows rapid microbial growth in a novel medium; note taped 'do not agitate'."), 

            Clue("c_keycardlog","Access log","Keycard entries: victim (19:12), colleague (21:07), technician (18:59). No other entries."), 

            Clue("c_safety","Safety protocols binder","Page flagged: 'Never decant reactive medium near flame; ensure neutralization bath ready.'"), 

            Clue("c_bunsen","Bunsen burner","Knob off, but warm to the touch."), 

            Clue("c_gloves","Gloves & eyewash","One glove missing; eyewash unused; neutralization bath cover closed."), 

            Clue("c_note","Bench note","'Medium-7 unstable when shaken; test only under laminar hood.' Initials: victim."), 

            Clue("c_machine","Olympia typewriter","Sheet reads: 'Origin model validated; cascade risk if medium disturbed.' Half-typed."), 

            Clue("c_corridor","Corridor conversation","Two admin staff complaining about debts; neither has lab access."), 

            Clue("c_techbag","Tech bag","Contains roster, paleo book, and sealed envelope with petty cash."), 

            Clue("c_spill","Spill morphology","Spill pattern radiates from bench edge; suggests container slid off during agitation."), 

        ], 

        causes=[ 

            Cause("cause_agitation","Reactive medium was agitated near bench edge",["lab","protocol"]), 

            Cause("cause_no_neutral","No neutralization bath prepared",["protocol"]), 

            Cause("cause_burner_heat","Residual heat altered medium stability",["lab"]), 

            Cause("cause_glove_missing","Victim mishandled without proper PPE",["protocol"]), 

            Cause("cause_key_access_only","Only authorized staff present this evening",["access"]), 

            Cause("cause_colleague_arrival","Colleague arrived after incident onset",["time"]), 

            Cause("cause_container_slide","Container slid off due to vibration",["physics"]), 

            Cause("cause_victim_rushed","Victim rushed experimental validation",["human"]), 

            Cause("cause_no_eyewash","Delay in decontamination increased harm",["protocol"]), 

            Cause("cause_no_outsider","No outsider intervention plausible",["access"]), 

        ], 

        constraints=[ 

            Constraint("cons_access","negative","No outsider can be the proximate cause (access logs exclude outsiders).",cons_access), 

            Constraint("cons_time","ordering","Colleague arrived after the critical event began; colleague cannot be root cause.",cons_time), 

            Constraint("cons_protocol","required","A protocol breach must appear in the chain (it explains instability escalation).",cons_protocol), 

            Constraint("cons_parsimony","quality","Avoid redundant steps (no double-counting same effect).",cons_parsimony), 

        ], 

        solution=[ 

            {"rel":"triggers", "from":"Reactive medium was agitated near bench edge", "to":"Spill morphology indicates container slid off"}, 

            {"rel":"enables", "from":"No neutralization bath prepared", "to":"Delay in decontamination increased harm"}, 

            {"rel":"enables", "from":"Residual heat altered medium stability", "to":"Reactive medium was agitated near bench edge"}, 

            {"rel":"implies", "from":"Only authorized staff present this evening", "to":"No outsider intervention plausible"}, 

            {"rel":"enables", "from":"Victim rushed experimental validation", "to":"Mishandling without proper PPE"}, 

        ], 

        hint="Focus on protocol breaches + access logs. Outsiders are excluded; combine heat, agitation, and missing neutralization." 

    ) 

 

    # L2: Court steps 

    def cons_bystander(chain, ctx): 

        if chain: 

            root_text = chain[-1]["text"].lower() 

            if "vendor" in root_text: 

                return "Vendor set as root cause; contradicts call timeline." 

        return True 

 

    def cons_access2(chain, ctx): 

        ok = any(("blind" in s["text"].lower()) or ("maintenance" in s["text"].lower()) for s in chain) 

        return True if ok else "Missing access/coverage condition enabling placement." 

 

    L2 = Level( 

        id="L2", 

        title="Court steps", 

        end_state="A public statue's head lies shattered; scorch marks on a nearby plinth; emergency services cordon the square.", 

        meta="Location: civic square • Time: early morning • Crowd: sparse • CCTV: partial coverage", 

        roles=[ 

            Role("worker","Maintenance Worker",["authorized"]), 

            Role("activist","Masked Activist",["unknown-access"]), 

            Role("vendor","Street Vendor",["bystander"]), 

            Role("officer","Police Officer",["responder"]), 

        ], 

        clues=[ 

            Clue("c_blast","Blast overpressure","Damage consistent with small charge; directional pattern suggests placement under overhang."), 

            Clue("c_santana","Blue sedan","Parked within legal zone; no direct blast damage; engine cold."), 

            Clue("c_calls","Emergency calls","First call 06:58 (vendor); second 07:03 (officer on routine patrol)."), 

            Clue("c_cctv","CCTV gaps","Two cameras offline due to scheduled maintenance; blind spot covers statue base."), 

            Clue("c_flyer","Flyers","University talk on 'Truth and Institutions' scheduled at 09:00 nearby."), 

        ], 

        causes=[ 

            Cause("cause_charge_small","Small charge placed under overhang",["physics"]), 

            Cause("cause_timing_blind","Placement timed for CCTV blind spot",["access"]), 

            Cause("cause_symbolic_link","Symbolic attack linked to upcoming event",["motive"]), 

            Cause("cause_vendor_first","Vendor noticed blast first; not origin",["time"]), 

            Cause("cause_worker_maintenance","Maintenance created coverage gap (unwitting)",["access"]), 

            Cause("cause_decoy_noise","Decoy action diverted responders",["tactics"]), 

        ], 

        constraints=[ 

            Constraint("cons_bystander","negative","Bystanders cannot be proximate cause (vendor reported, did not place charge).",cons_bystander), 

            Constraint("cons_access2","required","CCTV blind spot or maintenance gap must figure into the chain.",cons_access2), 

        ], 

        solution=[ 

            {"rel":"triggers", "from":"Small charge placed under overhang", "to":"Blast damage pattern"}, 

            {"rel":"enables", "from":"Placement timed for CCTV blind spot", "to":"Small charge placed under overhang"}, 

            {"rel":"enables", "from":"Maintenance created coverage gap (unwitting)", "to":"Placement timed for CCTV blind spot"}, 

            {"rel":"implies", "from":"Vendor noticed blast first; not origin", "to":"Bystander excluded from cause"}, 

            {"rel":"implies", "from":"Symbolic attack linked to upcoming event", "to":"Motivation inferred"}, 

        ], 

        hint="Tie the maintenance gap to timing; exclude the vendor; keep the chain short and focused on enabling + trigger." 

    ) 

 

    return [L1, L2] 

 

# ---------- Game engine ---------- 

 

REL_TYPES = ["implies", "enables", "triggers"] 

 

class Game: 

    def _init_(self): 

        self.levels = make_levels() 

        self.level_idx = 0 

        self.score = 0 

        self.chain: List[Dict[str, str]] = []  # list of steps: {"text":..., "rel":...} 

        self.savefile = "capricorn_save.json" 

 

    # UI helpers 

    def line(self, char="-", n=60): 

        print(char * n) 

 

    def pause(self): 

        input("\nPress Enter to continue...") 

 

    def show_header(self, level: Level): 

        self.line("=") 

        print(f"Capricorn — Think Backwards Game (Level {self.level_idx+1}/{len(self.levels)})") 

        self.line("=") 

        print(f"Title: {level.title}") 

        print(f"End state:\n  {level.end_state}\n") 

        print(f"Meta: {level.meta}") 

        self.line("-") 

 

    def show_clues(self, level: Level): 

        print("Clues:") 

        for i, c in enumerate(level.clues, 1): 

            print(f"  [{i}] {c.title}: {c.text}") 

        self.line("-") 

 

    def show_constraints(self, level: Level): 

        print("Constraints:") 

        for c in level.constraints: 

            badge = {"negative":"[❌]", "required":"[✅]", "ordering":"[⏱]", "quality":"[⚖]"}.get(c.kind, "[•]") 

            print(f"  {badge} {c.text}") 

        self.line("-") 

 

    def show_causes(self, level: Level): 

        print("Cause candidates:") 

        for i, c in enumerate(level.causes, 1): 

            tags = f" ({', '.join(c.tags)})" if c.tags else "" 

            print(f"  [{i}] {c.text}{tags}") 

        self.line("-") 

 

    def show_chain(self, level: Level): 

        print("Backward chain (from END → earlier causes):") 

        print(f"  END: {level.end_state}") 

        for i, s in enumerate(self.chain, 1): 

            print(f"  [{i}] {s['rel']} ← {s['text']}") 

        self.line("-") 

 

    def add_step(self, level: Level): 

        self.show_causes(level) 

        try: 

            idx = int(input("Select cause number to add (or 0 to cancel): ").strip() or "0") 

        except ValueError: 

            print("Invalid number.") 

            return 

        if idx <= 0 or idx > len(level.causes): 

            print("Cancelled or out of range.") 

            return 

        cause = level.causes[idx-1] 

        print("Relation types:", ", ".join(REL_TYPES)) 

        rel = input("Choose relation (implies/enables/triggers): ").strip().lower() 

        if rel not in REL_TYPES: 

            print("Invalid relation.") 

            return 

        # Append cause as proximate earlier step (END → cause) 

        self.chain.append({"text": cause.text, "rel": rel}) 

        print(f"Added step: {rel} ← {cause.text}") 

 

    def remove_last(self): 

        if not self.chain: 

            print("Chain is empty.") 

            return 

        last = self.chain.pop() 

        print(f"Removed last step: {last['rel']} ← {last['text']}") 

 

    def clear_chain(self): 

        self.chain = [] 

        print("Chain cleared.") 

 

    def validate_chain(self, level: Level) -> Dict[str, Any]: 

        messages = [] 

        score_delta = 0 

 

        # basic parsimony score 

        seen = set() 

        for s in self.chain: 

            key = s["text"].lower().strip() 

            if key in seen: 

                messages.append(("bad", f"Redundant step detected: \"{s['text']}\"")) 

                score_delta -= 1 

            else: 

                score_delta += 2 

            seen.add(key) 

 

        # constraints 

        ctx = {"roles": level.roles, "clues": level.clues} 

        for cons in level.constraints: 

            res = cons.test(self.chain, ctx) 

            if res is True: 

                messages.append(("good", f"Constraint satisfied: {cons.text}")) 

                score_delta += 4 

            else: 

                messages.append(("bad", f"Constraint violation: {res}")) 

                score_delta -= 2 

 

        # structure suggestions 

        has_trigger = any(s["rel"] == "triggers" for s in self.chain) 

        has_enable = any(s["rel"] == "enables" for s in self.chain) 

        if not has_trigger: 

            messages.append(("warn", "No proximate trigger included; consider adding direct causal step.")) 

        if not has_enable: 

            messages.append(("warn", "No enabling condition included; consider adding context cause.")) 

 

        return {"messages": messages, "score_delta": score_delta} 

 

    def submit(self, level: Level): 

        res = self.validate_chain(level) 

        for kind, msg in res["messages"]: 

            prefix = {"good":"[OK] ", "bad":"[X]  ", "warn":"[!]  "}.get(kind, "") 

            print(prefix + msg) 

        self.score += res["score_delta"] 

        print(f"Score change: {res['score_delta']}  |  Total score: {self.score}") 

 

        has_bad = any(k == "bad" for k, _ in res["messages"]) 

        if not has_bad and len(self.chain) >= 2: 

            print("\nAccepted. Your reconstruction satisfies constraints.\n") 

            return True 

        else: 

            print("\nNot accepted. Fix violations or add clearer steps.\n") 

            return False 

 

    def give_up(self, level: Level): 

        print("Solution sketch (no score awarded):") 

        for e in level.solution: 

            print(f"  • {e['from']} — {e['rel']} —> {e['to']}") 

        print("Hint:", level.hint) 

 

    def save(self): 

        data = { 

            "level_idx": self.level_idx, 

            "score": self.score, 

            "chain": self.chain, 

        } 

        with open(self.savefile, "w", encoding="utf-8") as f: 

            json.dump(data, f, ensure_ascii=False, indent=2) 

        print(f"Progress saved to {self.savefile}") 

 

    def load(self): 

        if not os.path.exists(self.savefile): 

            print("No savefile found.") 

            return 

        with open(self.savefile, "r", encoding="utf-8") as f: 

            data = json.load(f) 

        self.level_idx = data.get("level_idx", 0) 

        self.score = data.get("score", 0) 

        self.chain = data.get("chain", []) 

        print(f"Progress loaded from {self.savefile}") 

 

    def play_level(self, level: Level): 

        self.chain = []  # reset per level 

        while True: 

            self.show_header(level) 

            self.show_clues(level) 

            self.show_constraints(level) 

            self.show_chain(level) 

            print("Actions:") 

            print("  1) Add step") 

            print("  2) Remove last step") 

            print("  3) Clear chain") 

            print("  4) Submit hypothesis") 

            print("  5) Reveal hint") 

            print("  6) Give up (show solution)") 

            print("  7) Save progress") 

            print("  8) Load progress") 

            print("  9) Quit") 

            choice = input("> ").strip() 

 

            if choice == "1": 

                self.add_step(level) 

            elif choice == "2": 

                self.remove_last() 

            elif choice == "3": 

                self.clear_chain() 

            elif choice == "4": 

                success = self.submit(level) 

                if success: 

                    print("Proceeding to next level...\n") 

                    break 

                else: 

                    self.pause() 

            elif choice == "5": 

                print("Hint:", level.hint) 

                self.pause() 

            elif choice == "6": 

                self.give_up(level) 

                print("You can still try to submit or proceed (no score gain for give up).") 

                proceed = input("Proceed to next level? (y/N): ").strip().lower() 

                if proceed == "y": 

                    break 

            elif choice == "7": 

                self.save() 

                self.pause() 

            elif choice == "8": 

                self.load() 

                self.pause() 

            elif choice == "9": 

                print("Goodbye.") 

                sys.exit(0) 

            else: 

                print("Invalid choice.") 

                self.pause() 

 

    def run(self): 

        print("Welcome to Capricorn — Think Backwards Game (CLI)") 

        print("Build a backward chain of causes that explains the end state while satisfying constraints.") 

        self.pause() 

        while self.level_idx < len(self.levels): 

            level = self.levels[self.level_idx] 

            self.play_level(level) 

            self.level_idx += 1 

 

        self.line("=") 

        print(f"All levels completed. Final score: {self.score}") 

        print("Try optimizing parsimony for a higher score next time.") 

        self.line("=") 

 

# ---------- Entry ---------- 

 

if _name_ == "_main_": 

    Game().run()  
