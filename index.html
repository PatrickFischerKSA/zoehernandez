<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Capricorn – Think Backwards Game (Browser-Version)</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; line-height: 1.5; }
    h1, h2, h3 { color: #222; }
    #layout { display: grid; grid-template-columns: 1.1fr 0.9fr; gap: 20px; }
    .panel { border: 1px solid #ccc; padding: 12px 16px; border-radius: 6px; background: #fafafa; }
    .panel h2 { margin-top: 0; }
    .badge { padding: 2px 6px; border-radius: 4px; font-size: 0.8em; }
    .neg { background:#ffe0e0; }
    .req { background:#e0ffe5; }
    .ord { background:#e0f0ff; }
    .qual { background:#f4e0ff; }
    ul { padding-left: 18px; }
    .clue-title { font-weight:bold; }
    .cause-tags { font-size:0.8em; color:#555; }
    .chain-item { margin: 2px 0; }
    .msg-good { color: #006600; }
    .msg-bad { color: #bb0000; }
    .msg-warn { color: #aa7700; }
    .controls { margin-top: 8px; display:flex; flex-wrap:wrap; gap:6px; }
    button { padding: 6px 10px; border-radius: 4px; border:1px solid #888; background:#eee; cursor:pointer; }
    button:hover { background:#e0e0e0; }
    select { padding: 4px; }
    #footer { margin-top:20px; font-size:0.85em; color:#555; }
    #score { font-weight:bold; }
    .hint { font-style: italic; }
    .solution-entry { margin: 2px 0; }
    @media (max-width: 900px) {
      #layout { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
<h1>Capricorn – Think Backwards Game</h1>
<p>Baue vom <strong>Endzustand</strong> aus eine rückwärts gerichtete Ursachen-Kette, die alle Constraints erfüllt.</p>

<label for="levelSelect"><strong>Level wählen:</strong></label>
<select id="levelSelect"></select>
<span id="scoreArea"> | Score: <span id="score">0</span></span>

<div id="layout">
  <div class="panel" id="leftPanel">
    <h2>Szenario</h2>
    <div id="endState"></div>
    <p id="meta"></p>
    <h3>Clues</h3>
    <div id="clues"></div>
    <h3>Constraints</h3>
    <div id="constraints"></div>
  </div>

  <div class="panel" id="rightPanel">
    <h2>Chain bauen</h2>
    <div>
      <label for="causeSelect">Cause:</label>
      <select id="causeSelect"></select>
      <label for="relSelect">Relation:</label>
      <select id="relSelect">
        <option value="implies">implies</option>
        <option value="enables">enables</option>
        <option value="triggers">triggers</option>
      </select>
      <button id="addBtn">Step hinzufügen</button>
    </div>
    <h3>Aktuelle Chain (END → frühere Ursachen)</h3>
    <div id="chainView"></div>
    <div class="controls">
      <button id="removeBtn">Letzten Step entfernen</button>
      <button id="clearBtn">Chain löschen</button>
      <button id="submitBtn">Hypothese prüfen</button>
      <button id="hintBtn">Hint</button>
      <button id="solutionBtn">Lösungsskizze</button>
    </div>
    <h3>Rückmeldung</h3>
    <div id="messages"></div>
    <div id="hintBox" class="hint"></div>
    <div id="solutionBox"></div>
  </div>
</div>

<div id="footer">
  <p><strong>Kurz-Anleitung:</strong> Lies Clues und Constraints, wähle sinnvolle Causes und verknüpfe sie mit <code>implies</code>, <code>enables</code> oder <code>triggers</code>. 
  Reiche deine Hypothese ein und verbessere sie, bis keine Constraints mehr verletzt sind.</p>
</div>

<script>
const REL_TYPES = ["implies", "enables", "triggers"];

const levels = [
  {
    id: "L1",
    title: "Lab incident",
    end_state: "A biologist is found dead on the lab floor, surrounded by broken glassware and a spilled translucent solution. A colleague kneels beside him, holding his hand.",
    meta: "Location: research lab • Time: late evening • Weather: clear • Access: restricted keycard",
    clues: [
      {id:"c_micropetridish", title:"Microscope view", text:"A petri dish shows rapid microbial growth in a novel medium; note taped 'do not agitate'."},
      {id:"c_keycardlog", title:"Access log", text:"Keycard entries: victim (19:12), colleague (21:07), technician (18:59). No other entries."},
      {id:"c_safety", title:"Safety protocols binder", text:"Page flagged: 'Never decant reactive medium near flame; ensure neutralization bath ready.'"},
      {id:"c_bunsen", title:"Bunsen burner", text:"Knob off, but warm to the touch."},
      {id:"c_gloves", title:"Gloves & eyewash", text:"One glove missing; eyewash unused; neutralization bath cover closed."},
      {id:"c_note", title:"Bench note", text:"'Medium-7 unstable when shaken; test only under laminar hood.' Initials: victim."},
      {id:"c_machine", title:"Olympia typewriter", text:"Sheet reads: 'Origin model validated; cascade risk if medium disturbed.' Half-typed."},
      {id:"c_corridor", title:"Corridor conversation", text:"Two admin staff complaining about debts; neither has lab access."},
      {id:"c_techbag", title:"Tech bag", text:"Contains roster, paleo book, and sealed envelope with petty cash."},
      {id:"c_spill", title:"Spill morphology", text:"Spill pattern radiates from bench edge; suggests container slid off during agitation."}
    ],
    causes: [
      {id:"cause_agitation", text:"Reactive medium was agitated near bench edge", tags:["lab","protocol"]},
      {id:"cause_no_neutral", text:"No neutralization bath prepared", tags:["protocol"]},
      {id:"cause_burner_heat", text:"Residual heat altered medium stability", tags:["lab"]},
      {id:"cause_glove_missing", text:"Victim mishandled without proper PPE", tags:["protocol"]},
      {id:"cause_key_access_only", text:"Only authorized staff present this evening", tags:["access"]},
      {id:"cause_colleague_arrival", text:"Colleague arrived after incident onset", tags:["time"]},
      {id:"cause_container_slide", text:"Container slid off due to vibration", tags:["physics"]},
      {id:"cause_victim_rushed", text:"Victim rushed experimental validation", tags:["human"]},
      {id:"cause_no_eyewash", text:"Delay in decontamination increased harm", tags:["protocol"]},
      {id:"cause_no_outsider", text:"No outsider intervention plausible", tags:["access"]}
    ],
    constraints: [
      {id:"cons_access", kind:"negative", text:"No outsider can be the proximate cause (access logs exclude outsiders)."},
      {id:"cons_time", kind:"ordering", text:"Colleague arrived after the critical event began; colleague cannot be root cause."},
      {id:"cons_protocol", kind:"required", text:"A protocol breach must appear in the chain (it explains instability escalation)."},
      {id:"cons_parsimony", kind:"quality", text:"Avoid redundant steps (no double-counting same effect)."}
    ],
    hint: "Focus on protocol breaches + access logs. Outsiders are excluded; combine heat, agitation, and missing neutralization.",
    solution: [
      {rel:"triggers", from:"Reactive medium was agitated near bench edge", to:"Spill morphology indicates container slid off"},
      {rel:"enables", from:"No neutralization bath prepared", to:"Delay in decontamination increased harm"},
      {rel:"enables", from:"Residual heat altered medium stability", to:"Reactive medium was agitated near bench edge"},
      {rel:"implies", from:"Only authorized staff present this evening", to:"No outsider intervention plausible"},
      {rel:"enables", from:"Victim rushed experimental validation", to:"Mishandling without proper PPE"}
    ]
  },
  {
    id: "L2",
    title: "Court steps",
    end_state: "A public statue's head lies shattered; scorch marks on a nearby plinth; emergency services cordon the square.",
    meta: "Location: civic square • Time: early morning • Crowd: sparse • CCTV: partial coverage",
    clues: [
      {id:"c_blast", title:"Blast overpressure", text:"Damage consistent with small charge; directional pattern suggests placement under overhang."},
      {id:"c_santana", title:"Blue sedan", text:"Parked within legal zone; no direct blast damage; engine cold."},
      {id:"c_calls", title:"Emergency calls", text:"First call 06:58 (vendor); second 07:03 (officer on routine patrol)."},
      {id:"c_cctv", title:"CCTV gaps", text:"Two cameras offline due to scheduled maintenance; blind spot covers statue base."},
      {id:"c_flyer", title:"Flyers", text:"University talk on 'Truth and Institutions' scheduled at 09:00 nearby."}
    ],
    causes: [
      {id:"cause_charge_small", text:"Small charge placed under overhang", tags:["physics"]},
      {id:"cause_timing_blind", text:"Placement timed for CCTV blind spot", tags:["access"]},
      {id:"cause_symbolic_link", text:"Symbolic attack linked to upcoming event", tags:["motive"]},
      {id:"cause_vendor_first", text:"Vendor noticed blast first; not origin", tags:["time"]},
      {id:"cause_worker_maintenance", text:"Maintenance created coverage gap (unwitting)", tags:["access"]},
      {id:"cause_decoy_noise", text:"Decoy action diverted responders", tags:["tactics"]}
    ],
    constraints: [
      {id:"cons_bystander", kind:"negative", text:"Bystanders cannot be proximate cause (vendor reported, did not place charge)."},
      {id:"cons_access2", kind:"required", text:"CCTV blind spot or maintenance gap must figure into the chain."}
    ],
    hint: "Tie the maintenance gap to timing; exclude the vendor; keep the chain short and focused on enabling + trigger.",
    solution: [
      {rel:"triggers", from:"Small charge placed under overhang", to:"Blast damage pattern"},
      {rel:"enables", from:"Placement timed for CCTV blind spot", to:"Small charge placed under overhang"},
      {rel:"enables", from:"Maintenance created coverage gap (unwitting)", to:"Placement timed for CCTV blind spot"},
      {rel:"implies", from:"Vendor noticed blast first; not origin", to:"Bystander excluded from cause"},
      {rel:"implies", from:"Symbolic attack linked to upcoming event", to:"Motivation inferred"}
    ]
  }
];

// --- constraint functions (portiert aus Python) ---
function cons_access(chain) {
  const outsiderMention = chain.some(s => s.text.toLowerCase().includes("outsider"));
  return outsiderMention ? "Chain references outsider cause, violating access logs." : true;
}

function cons_time(chain) {
  if (chain.length > 0) {
    const rootText = chain[chain.length-1].text.toLowerCase();
    if (rootText.includes("colleague")) {
      return "Colleague placed as root cause contrary to arrival time.";
    }
  }
  return true;
}

function cons_protocol(chain) {
  const keywords = ["protocol", "neutralization", "ppe", "agitated", "unstable"];
  const hasBreach = chain.some(s => {
    const t = s.text.toLowerCase();
    return keywords.some(k => t.includes(k));
  });
  return hasBreach ? true : "No protocol breach included; missing necessary explanation.";
}

function cons_parsimony(chain) {
  const seen = new Set();
  let redundant = 0;
  for (const s of chain) {
    const k = s.text.trim().toLowerCase();
    if (seen.has(k)) redundant += 1;
    seen.add(k);
  }
  if (redundant > 0) {
    return `Redundancy detected (${redundant} duplicate step${redundant>1?"s":""}).`;
  }
  return true;
}

function cons_bystander(chain) {
  if (chain.length > 0) {
    const rootText = chain[chain.length-1].text.toLowerCase();
    if (rootText.includes("vendor")) {
      return "Vendor set as root cause; contradicts call timeline.";
    }
  }
  return true;
}

function cons_access2(chain) {
  const ok = chain.some(s => {
    const t = s.text.toLowerCase();
    return t.includes("blind") || t.includes("maintenance");
  });
  return ok ? true : "Missing access/coverage condition enabling placement.";
}

// mapping constraint id -> function
const constraintFns = {
  cons_access,
  cons_time,
  cons_protocol,
  cons_parsimony,
  cons_bystander,
  cons_access2
};

// --- game state ---
let currentLevelIndex = 0;
let chain = [];
let score = 0;

const levelSelect = document.getElementById("levelSelect");
const scoreSpan = document.getElementById("score");
const endStateDiv = document.getElementById("endState");
const metaP = document.getElementById("meta");
const cluesDiv = document.getElementById("clues");
const constraintsDiv = document.getElementById("constraints");
const causeSelect = document.getElementById("causeSelect");
const relSelect = document.getElementById("relSelect");
const chainView = document.getElementById("chainView");
const messagesDiv = document.getElementById("messages");
const hintBox = document.getElementById("hintBox");
const solutionBox = document.getElementById("solutionBox");

function initLevelSelect() {
  levels.forEach((lvl, idx) => {
    const opt = document.createElement("option");
    opt.value = idx;
    opt.textContent = `${idx+1}: ${lvl.title}`;
    levelSelect.appendChild(opt);
  });
  levelSelect.addEventListener("change", () => {
    currentLevelIndex = parseInt(levelSelect.value, 10);
    chain = [];
    renderAll();
  });
}

function renderAll() {
  const lvl = levels[currentLevelIndex];
  endStateDiv.textContent = lvl.end_state;
  metaP.textContent = lvl.meta;

  // clues
  cluesDiv.innerHTML = "";
  const ulC = document.createElement("ul");
  lvl.clues.forEach(c => {
    const li = document.createElement("li");
    const spanT = document.createElement("span");
    spanT.className = "clue-title";
    spanT.textContent = c.title + ": ";
    li.appendChild(spanT);
    li.appendChild(document.createTextNode(c.text));
    ulC.appendChild(li);
  });
  cluesDiv.appendChild(ulC);

  // constraints
  constraintsDiv.innerHTML = "";
  const ulCons = document.createElement("ul");
  lvl.constraints.forEach(c => {
    const li = document.createElement("li");
    const badge = document.createElement("span");
    badge.classList.add("badge");
    if (c.kind === "negative") badge.classList.add("neg");
    else if (c.kind === "required") badge.classList.add("req");
    else if (c.kind === "ordering") badge.classList.add("ord");
    else if (c.kind === "quality") badge.classList.add("qual");
    badge.textContent = c.kind;
    li.appendChild(badge);
    li.appendChild(document.createTextNode(" " + c.text));
    ulCons.appendChild(li);
  });
  constraintsDiv.appendChild(ulCons);

  // causes select
  causeSelect.innerHTML = "";
  lvl.causes.forEach((c, i) => {
    const opt = document.createElement("option");
    opt.value = i;
    const tagText = c.tags && c.tags.length ? " ("+c.tags.join(", ")+")" : "";
    opt.textContent = `${i+1}: ${c.text}${tagText}`;
    causeSelect.appendChild(opt);
  });

  renderChain();
  messagesDiv.innerHTML = "";
  hintBox.textContent = "";
  solutionBox.innerHTML = "";
  levelSelect.value = currentLevelIndex;
  scoreSpan.textContent = score;
}

function renderChain() {
  const lvl = levels[currentLevelIndex];
  chainView.innerHTML = "";
  const pEnd = document.createElement("p");
  pEnd.textContent = "END: " + lvl.end_state;
  chainView.appendChild(pEnd);
  if (chain.length === 0) {
    const p = document.createElement("p");
    p.textContent = "(noch keine Schritte)";
    chainView.appendChild(p);
  } else {
    const ul = document.createElement("ul");
    chain.forEach((s, idx) => {
      const li = document.createElement("li");
      li.className = "chain-item";
      li.textContent = `[${idx+1}] ${s.rel} ← ${s.text}`;
      ul.appendChild(li);
    });
    chainView.appendChild(ul);
  }
}

function addStep() {
  const lvl = levels[currentLevelIndex];
  const idx = parseInt(causeSelect.value, 10);
  if (isNaN(idx) || idx < 0 || idx >= lvl.causes.length) return;
  const cause = lvl.causes[idx];
  const rel = relSelect.value;
  if (!REL_TYPES.includes(rel)) return;
  chain.push({text: cause.text, rel: rel});
  renderChain();
}

function removeLast() {
  if (chain.length > 0) {
    chain.pop();
    renderChain();
  }
}

function clearChain() {
  chain = [];
  renderChain();
}

function validateChain() {
  const messages = [];
  let delta = 0;

  // parsimony score
  const seen = new Set();
  for (const s of chain) {
    const key = s.text.toLowerCase().trim();
    if (seen.has(key)) {
      messages.push({kind:"bad", msg:`Redundant step detected: "${s.text}"`});
      delta -= 1;
    } else {
      delta += 2;
    }
    seen.add(key);
  }

  const lvl = levels[currentLevelIndex];
  // constraints
  for (const cons of lvl.constraints) {
    const fn = constraintFns[cons.id];
    if (typeof fn === "function") {
      const res = fn(chain);
      if (res === true) {
        messages.push({kind:"good", msg:`Constraint satisfied: ${cons.text}`});
        delta += 4;
      } else {
        messages.push({kind:"bad", msg:`Constraint violation: ${res}`});
        delta -= 2;
      }
    }
  }

  // structure suggestions
  const hasTrigger = chain.some(s => s.rel === "triggers");
  const hasEnable = chain.some(s => s.rel === "enables");
  if (!hasTrigger) messages.push({kind:"warn", msg:"No proximate trigger included; consider adding direct causal step."});
  if (!hasEnable) messages.push({kind:"warn", msg:"No enabling condition included; consider adding context cause."});

  return {messages, delta};
}

function submitChain() {
  const {messages, delta} = validateChain();
  messagesDiv.innerHTML = "";
  messages.forEach(m => {
    const p = document.createElement("p");
    if (m.kind === "good") p.className = "msg-good";
    else if (m.kind === "bad") p.className = "msg-bad";
    else if (m.kind === "warn") p.className = "msg-warn";
    p.textContent = m.msg;
    messagesDiv.appendChild(p);
  });
  score += delta;
  scoreSpan.textContent = score;

  const hasBad = messages.some(m => m.kind === "bad");
  if (!hasBad && chain.length >= 2) {
    const p = document.createElement("p");
    p.className = "msg-good";
    p.textContent = "Accepted. Deine Rekonstruktion erfüllt die Constraints! Du kannst optional ein anderes Level wählen.";
    messagesDiv.appendChild(p);
  } else {
    const p = document.createElement("p");
    p.className = "msg-warn";
    p.textContent = "Noch nicht akzeptiert – verbessere deine Chain (Fehlermeldungen oben beachten).";
    messagesDiv.appendChild(p);
  }
}

function showHint() {
  const lvl = levels[currentLevelIndex];
  hintBox.textContent = "Hint: " + lvl.hint;
}

function showSolution() {
  const lvl = levels[currentLevelIndex];
  solutionBox.innerHTML = "<strong>Lösungsskizze:</strong>";
  const ul = document.createElement("ul");
  lvl.solution.forEach(e => {
    const li = document.createElement("li");
    li.className = "solution-entry";
    li.textContent = `${e.from} — ${e.rel} —> ${e.to}`;
    ul.appendChild(li);
  });
  solutionBox.appendChild(ul);
}

// button wiring
document.getElementById("addBtn").addEventListener("click", addStep);
document.getElementById("removeBtn").addEventListener("click", removeLast);
document.getElementById("clearBtn").addEventListener("click", clearChain);
document.getElementById("submitBtn").addEventListener("click", submitChain);
document.getElementById("hintBtn").addEventListener("click", showHint);
document.getElementById("solutionBtn").addEventListener("click", showSolution);

// init
initLevelSelect();
renderAll();
</script>
</body>
</html>
